<%BEGIN_DEFINITION_TEMPLATE>
/*************
* conv1d.cpp
*
* Conv1D Layer
* Hardware Plateform: ESP-32
*
* This file defines the functions needed to build a dense layer, and perform a forward pass.
*/

#include "dense.h"


struct Dense buildDense(<%WEIGHT_DATATYPE_DELIMITER>* W, <%WEIGHT_DATATYPE_DELIMITER>* b, <%INDEX_DATATYPE_DELIMITER> input_size, <%INDEX_DATATYPE_DELIMITER> output_size, <%ACTIVATION_DATATYPE_DELIMITER> activation)
{
	struct Dense layer;

	layer.weights = W;
	layer.biases = b;

	layer.input_shape[0] = input_size;
	layer.output_shape[0] = output_size;
    layer.weight_shape[0] = input_size;
    layer.weight_shape[1] = output_size;
    layer.activation = activation;
    num_layers++;
	return layer;
}


float * fwdDense(Dense* layer, <%LAYER_DATATYPE_DELIMITER>* input)
{
	// Dereference the provided layer to simplify the code
	struct Dense L = *layer;
   
    float * h = (float*)malloc(L.output_shape[0] * sizeof(float));

	// Loop through to calculate the output at each point
	for(<%INDEX_DATATYPE_DELIMITER> i = 0; i < L.output_shape[0]; i++)
	{
		// Start with the bias
		h[i] = L.biases[i];

		for(<%INDEX_DATATYPE_DELIMITER> j = 0; j < L.input_shape[0]; j++)
		{
            h[i] += *(L.weights + j*L.weight_shape[1] + i)*input[j];
		}


        // TODO: Actual lookup table
         if (L.activation=='r'){
             h[i]= max(h[i], 0.0);
         }
 
         if (L.activation== 't'){
             h[i]=tanh(h[i]);
         }
	}

    free(input);
    *layer = L;
    return h;

}
<%END_DEFINITION_TEMPLATE>


<%BEGIN_INITIALIZE_TEMPLATE>
struct Dense <%LAYER_NAME> = buildDense(&<%WEIGHT_NAME>[0][0], <%BIAS_NAME>, <%INPUT_SIZE>, <%OUTPUT_SIZE>, <%ACTIVATION>);
<%END_INITIALIZE_TEMPLATE>

<%BEGIN_CALL_TEMPLATE>
data1D = fwdDense(&<%LAYER_NAME>, <%INPUT>);
<%END_CALL_TEMPLATE>
