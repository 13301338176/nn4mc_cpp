<%BEGIN_DEFINITION_TEMPLATE>

/*************
* conv2d.cpp
*
* Conv2D Layer
* Hardware Plateform: ESP-32
*
* This file defines the functions needed to build a 2D Convolutional layer, and perform a forward pass.
* TODO: This template.
*/

#include "conv2d.h"
#include <stdlib.h>

#define max(a, b) (((a)>(b) ? (a) : (b)))
#define min(a, b) (((a)<(b) ? (a) : (b)))

struct Conv2D buildConv2D(<%WEIGHT_DATATYPE_DELIMITER>* W, <%WEIGHT_DATATYPE_DELIMITER>* b, <%INDEX_DATATYPE_DELIMITER> kernel_shape_0, <%INDEX_DATATYPE_DELIMITER> kernel_shape_1, <%INDEX_DATATYPE_DELIMITER> filters, <%INDEX_DATATYPE_DELIMITER> strides_0, <%INDEX_DATATYPE_DELIMITER> strides_1, <%INDEX_DATATYPE_DELIMITER> input_shape_0,<%INDEX_DATATYPE_DELIMITER> input_shape_1,<%INDEX_DATATYPE_DELIMITER> input_shape_2, <%ACTIVATION_DATATYPE_DELIMITER> activation)
{
	struct Conv2D layer;

	layer.weights = W;
	layer.bias = b;

	layer.weight_shape[0] = kernel_shape_0;
	layer.weight_shape[1] = kernel_shape_1;
	layer.weight_shape[2] = input_shape_2;
	layer.weight_shape[3] = filters;

    layer.filters = filters;
    layer.activation= activation;
    layer.kernel_shape[0] = kernel_shape_0;
    layer.kernel_shape[1] = kernel_shape_1;

	layer.strides[0] = strides_0;				// NOTE: NOT YET IMPLEMENTED
	layer.strides[1] = strides_1;

	layer.input_shape[0] = input_shape_0;
	layer.input_shape[1] = input_shape_1;
	layer.input_shape[2] = input_shape_2;

	layer.output_shape[0] = layer.input_shape[0] - layer.kernel_shape[0] + 1;
	layer.output_shape[1] = layer.input_shape[1] - layer.kernel_shape[1] + 1;
	layer.output_shape[2] = layer.filters;

	return layer;
}


<%LAYER_DATATYPE_DELIMITER>* fwdConv2D(struct Conv2D L, <%LAYER_DATATYPE_DELIMITER>* input)
{

     <%LAYER_DATATYPE_DELIMITER> * h = (<%LAYER_DATATYPE_DELIMITER>*)malloc(L.output_shape[0]*L.output_shape[1]*L.output_shape[2] * sizeof(<%LAYER_DATATYPE_DELIMITER>));

	for(<%INDEX_DATATYPE_DELIMITER> i = 0; i < L.output_shape[0]; i++)
	{
		for(<%INDEX_DATATYPE_DELIMITER> j = 0; j < L.output_shape[1]; j++)
		{
			for(<%INDEX_DATATYPE_DELIMITER> k = 0; k < L.output_shape[2]; k++)
			{
				int output_idx = i * L.output_shape[1] * L.output_shape[2] + j * L.output_shape[2] + k;

				h[output_idx] = L.bias[k];


				for(<%INDEX_DATATYPE_DELIMITER> kernel_position_x = 0; kernel_position_x < L.kernel_shape[0]; kernel_position_x++)
				{

                    int mm = L.kernel_shape[0] - 1 - kernel_position_x;

					for(<%INDEX_DATATYPE_DELIMITER> kernel_position_y = 0; kernel_position_y < L.kernel_shape[1]; kernel_position_y++)
					{				

                        for (<%INDEX_DATATYPE_DELIMITER> f=0; f<L.filters; f++){
                        int nn = L.kernel_shape[1] - 1 - kernel_position_y;

                        int ii = i + (L.kernel_shape[1]/2 - mm);
                        int jj = j + (L.kernel_shape[0]/2 - nn);

                        if (ii >= 0 && ii < i && jj >= 0 && jj < j){
                            h[output_idx] += *(L.weights + L.weight_shape[3]*L.weight_shape[2]*L.weight_shape[1]*kernel_position_x + L.weight_shape[2]*L.weight_shape[1]* kernel_position_y + L.weight_shape[1]*f) * (input[L.input_shape[1]*L.input_shape[2]*ii + L.input_shape[2] * jj]);
                       }
                   } 

                }
            }

				// Now perform the activation function
				// NOTE: NEED TO IMPLEMENT
        // TODO: Make more elegant:
        // linear not here cause no action

        if (L.activation==0x08){ //sigmoid
            h[i] = exp(h[i])/(exp(h[i]) + 1);
        }

        if (L.activation==0x04){ //softplus
            h[i] = log(exp(h[i]) + 1);
        }

        if (L.activation==0x05){ //softsign
            h[i] = h[i] / (abs(h[i]) + 1);
        }

        if (L.activation==0x09){ //hard_sigmoid
            if (h[i] < -2.5){
                h[i] = 0.0;
            } else if (h[i] > 2.5){
                h[i] = 1.0;
            } else{
                h[i] = 0.2*h[i] + 0.5;
            }
        }

        if (L.activation==0xA){ //exponential
            h[i] = (<%LAYER_DATATYPE_DELIMITER>)expf((float)h[i]);
        }
        
         if (L.activation==0x06){ //relu
             h[i]= max(h[i], 0.0);
         }

         if (L.activation== 0x07){ //tanh
             h[i]=tanh(h[i]);
         }
         if (L.activation==0x00){ //softmax
             float sum_exp = 0.0;
             for (int i=0; i<L.output_shape[0]; i++){
                 sum_exp+= expf(h[i]);
             }
             for (int i=0; i<L.output_shape[0];i++){
                 float calc = expf(h[i]) / sum_exp;
                 if (isnan(calc)){
                     h[i] = 1.0;
                 } else h[i] = (<%LAYER_DATATYPE_DELIMITER>)(expf(h[i]) / sum_exp);
             }
         }

			}
		}
	}
    free(input);
    return h;
}

<%END_DEFINITION_TEMPLATE>

<%BEGIN_INITIALIZE_TEMPLATE>
        <%LAYER_NAME> = buildConv2D(&<%WEIGHT_NAME>[0], <%BIAS_NAME>, <%KERNEL_SHAPE_0>, <%KERNEL_SHAPE_1>, <%FILTERS>, <%STRIDE_SHAPE_0>, <%STRIDE_SHAPE_1>, <%INPUT_SHAPE_0>, <%INPUT_SHAPE_1>, <%INPUT_SHAPE_2>, <%ACTIVATION>);
<%END_INITIALIZE_TEMPLATE>

<%BEGIN_CALL_TEMPLATE>
        data = fwdConv2D(<%LAYER_NAME>, <%INPUT>);
<%END_CALL_TEMPLATE>
